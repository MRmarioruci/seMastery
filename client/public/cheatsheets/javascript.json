{
	"collectionName": "javascript",
	"title": "Javascript",
	"icon": "https://api.iconify.design/logos:javascript.svg",
	"color": "F7DF1E",
	"highlighter": "js",
	"groups": [
		{
			"title": "Basics",
			"docs": [
				{
					"title": "What is Javascript?",
					"description": "JavaScript is a high-level, interpreted programming language primarily used for web development. It is often executed in web browsers and allows developers to create interactive and dynamic web applications. ",
					"image": "",
					"code": ""
				},
				{
					"title": "Difference between let, const and var",
					"description": "All 3 are used for variable declaration. \n <p><strong>var:</strong> Function-scoped and are hoisted to the top of their containing function or global scope. They can be redeclared within the same scope, and their values can be reassigned.<\/p> <p><strong>let:<\/strong> Block-scoped, which means they are confined to the nearest enclosing block (e.g., a loop or an if statement). They are also hoisted but are not initialized until they are declared. let variables cannot be redeclared in the same scope but can have their values reassigned.<\/p> <p><strong>const:<\/strong> Variables declared with const are also block-scoped, and they cannot be reassigned after they are assigned a value. This makes const suitable for defining constants.<\/p>",
					"image": "",
					"code": ""
				},
				{
					"title": "Coercion",
					"description": "Coercion is the process of converting a value from one data type to another. This can happen implicitly or explicitly. Implicitly: Javascript automatically converts types, Explicitly: You order the conversion",
					"image": "",
					"code": ""
				},
				{
					"title": "Scope",
					"description": "Each function gets its own scope. Scope is basically a collection of variables as well as the rules for how those variables are accessed by name",
					"image": "",
					"code": ""
				},
				{
					"title": "use strict",
					"description": "Directive enforces stricter error-checking and helps catch common coding mistakes.",
					"image": "",
					"code": "// Without \"use strict\"\nfunction duplicateParams(a, a) {\n  return a + a;\n}\n\n// With \"use strict\"\n\"use strict\";\nfunction strictDuplicateParams(a, a) {\n  // Throws a SyntaxError\n  return a + a;\n}"
				},
				{
					"title": "Difference between == & ===",
					"description": "<p>== (loose equality): This operator compares values for equality after performing type coercion. It converts the operands to the same type before making the comparison. For example, \"5\" == 5 would evaluate to true because the string is coerced to a number.</p><p>=== (strict equality): This operator compares both the values and the types of the operands. It returns true if both the values and types are the same. For example, \"5\" === 5 would evaluate to false because the types are different.</p>",
					"image": "",
					"code": "// Loose Equality (==)\nconsole.log('5' == 5); // Outputs: true because of type coercion\n// Strict Equality (===)\nconsole.log('5' === 5);\n// Outputs: false because types are different"
				},
				{
					"title": "null vs undefined",
					"description": "undefined: Something hasn't been initialized, null: Something is currently unavailable",
					"image": "",
					"code": ""
				},
				{
					"title": "Immediately Invoked Function Expressions",
					"description": "Allows you to define and execute a function immediately after its creation. It's often used to encapsulate variables and functions, creating a private scope for them",
					"image": "",
					"code": "(function () {\n  // This code is inside the IIFE and is executed immediately\n  let message = 'Hello, I am inside an IIFE!';\n  console.log(message);\n})();\n// Outside the IIFE, you can't access the 'message' variable"
				},
				{
					"title": "Closures",
					"description": "<b>A closure in JavaScript is a function that has access to variables from its containing (enclosing) function</b>, even after the enclosing function has finished executing. Closures work because functions in JavaScript 'remember' their lexical scope, which means they remember the environment in which they were created. This allows you to create private variables and encapsulated functionality. Closures are often used to create modular and maintainable code.",
					"image": "",
					"code": "function outerFunction() {\n  let outerVar = 'I am from outerFunction';\n  function innerFunction() {\n    console.log(outerVar);\n  }\n  return innerFunction;\n}\n\nconst closure = outerFunction();\nclosure();\n// This will print 'I am from outerFunction' because innerFunction still has access to outerVar even though outerFunction has finished executing."
				},
				{
					"title": "Event loop",
					"description": "The event loop is a mechanism that enables JavaScript to execute code asynchronously, handle events, and manage I/O operations without blocking the main execution thread. It ensures that tasks are processed in a timely and efficient manner. Great visual article here: <a href='https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke' target='_blank'>dev.to</a>",
					"image": "",
					"code": ""
				},
				{
					"title": "Higher Order Functions",
					"description": "Functions that can take other functions as arguments or return functions as their results.",
					"image": "",
					"code": "const add = (x) => x + 2;\nconst multiply = (x) => x * 3;\nconst composedFunction = (x) => multiply(add(x));\nconst result = composedFunction(5);\n// result is 21 (5 + 2 = 7, 7 * 3 = 21)"
				},
				{
					"title": "Hoisting",
					"description": "Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their containing scope during the compilation phase, before the code is executed. This means you can use a variable or function before it's declared in your code without raising an error. Functions are stored with a reference to the entire function, variables with the var keyword with the value of undefined, and variables with the let and const keyword are stored uninitialized.",
					"image": "",
					"code": "console.log(x); // Outputs: undefined\nvar x = 10;"
				},
				{
					"title": "Function declaration vs function expression?",
					"description": "Function Declaration: A statement that defines a named function with the function keyword, Function Expression: A function that is assigned to a variable. Difference is hoisting",
					"image": "",
					"code": "// Function declaration \nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\n\n// Function expression \nconst greet = function (name) {\n  return `Hello, ${name}!`;\n};\n"
				},
				{
					"title": "Rest parameter vs spread operator",
					"description": "Rest: Allows a function to accept indefinite amount oa parameter, Spread: Allows iterables to be expanded into single arguments/elements",
					"image": "",
					"code": "// Rest \nfunction sum(...numbers) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4, 5)); // 15\n// Spread operator \nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combinedArray = [...arr1, ...arr2]; // Combines the arrays\nconsole.log(combinedArray); // [1, 2, 3, 4, 5, 6]\n"
				},
				{
					"title": "Callback function",
					"description": "A callback function is a function that is passed to another function as an argument and is executed after some operation has been completed",
					"image": "",
					"code": "function modifyArray(arr, callback) {\n  // do something to arr here\n  arr.push(100);\n  // then execute the callback function that was passed\n  callback();\n}\n\nconst arr = [1, 2, 3, 4, 5];\nmodifyArray(arr, () => {\n  console.log('array has been modified', arr);\n});\n"
				},
				{
					"title": "Event bubbling",
					"description": "Event bubbling is the concept in which an event triggers at the deepest possible element, and triggers on parent elements in nesting order. As a result, when clicking on a child element one may exhibit the handler of the parent activating.",
					"image": "",
					"code": ""
				}
			]
		},
		{
			"title": "Promises and Asynchronous Programming",
			"docs": [
				{
					"title": "What is a Promise in JavaScript?",
					"description": "A Promise is a JavaScript object representing the eventual completion or failure of an asynchronous operation. It provides a way to handle asynchronous operations more easily and avoid callback hell.",
					"code": "// Create a function that returns a Promise\nfunction fetchData() {\n  return new Promise((resolve, reject) => {\n    // Simulate an asynchronous operation (e.g., fetching data from a server)\n    setTimeout(() => {\n      const data = { message: \"Data fetched successfully\" };\n      // Resolve the Promise with the data\n      resolve(data);\n      \n      // Uncomment the following line to simulate an error:\n      // reject(\"Error: Unable to fetch data\");\n    }, 2000); // Simulate a 2-second delay\n  });\n}\n\n// Use the Promise\nfetchData()\n  .then((result) => {\n    console.log(result.message); // Data fetched successfully\n  })\n  .catch((error) => {\n    console.error(error); // Handle errors here\n  });"
				},
				{
					"title": "How do you create a Promise in JavaScript?",
					"description": "You can create a Promise using the `Promise` constructor. It takes a single argument, a function (executor), which has two parameters: `resolve` and `reject`. You call `resolve` when the asynchronous operation is successful and `reject` when it fails.",
					"code": "const myPromise = new Promise((resolve, reject) => {\n  // Perform some asynchronous operation\n  if (/* operation successful */) {\n    resolve(result);\n  } else {\n    reject(error);\n  }\n});"
				},
				{
					"title": "What is the purpose of `async/await` in JavaScript?",
					"description": "The `async/await` syntax is used to simplify working with Promises. It allows you to write asynchronous code that looks more like synchronous code, making it easier to read and maintain. The `async` keyword defines a function as asynchronous, and `await` is used inside such a function to wait for a Promise to resolve or reject.",
					"code": ""
				},
				{
					"title": "How do you define an `async` function in JavaScript?",
					"description": "You can define an `async` function using the `async` keyword before the function declaration. An `async` function always returns a Promise.",
					"code": "async function myAsyncFunction() {\n  // Asynchronous code using await\n  const result = await somePromise;\n  return result;\n}"
				},
				{
					"title": "What is the difference between `Promise.all()` and `Promise.race()`?",
					"description": "`Promise.all()` waits for all Promises in an array to resolve, and it returns an array of their results. In contrast, `Promise.race()` waits for any one of the Promises in an array to resolve or reject, and it returns the result or error of the first Promise that settles.",
					"code": ""
				},
				{
					"title": "How do you handle errors in `async/await`?",
					"description": "You can use a `try/catch` block to handle errors in `async/await`. If an error occurs within the `try` block or any awaited Promise rejects, control is passed to the `catch` block, where you can handle the error.",
					"code": "async function myAsyncFunction() {\n  try {\n    const result = await somePromise;\n    // Code if successful\n  } catch (error) {\n    // Handle the error\n  }\n}"
				},
				{
					"title": "What is Promise chaining?",
					"description": "Promise chaining is a technique where you chain multiple asynchronous operations together using the `.then()` method. It allows you to perform a series of asynchronous tasks sequentially.",
					"code": "myPromise.then((result1) => {\n  // Code to handle result1\n  return result2Promise;\n}).then((result2) => {\n  // Code to handle result2\n});"
				},
				{
					"title": "Explain the event loop in the context of asynchronous JavaScript.",
					"description": "The event loop is a fundamental concept in JavaScript's concurrency model. It allows asynchronous code to run efficiently by handling tasks in a non-blocking manner. When a Promise is resolved, its `.then()` callbacks are placed in the event queue and executed when the call stack is empty.",
					"code": ""
				},
				{
					"title": "Explain the difference between microtasks and macrotasks in the context of the event loop.",
					"description": "Microtasks (e.g., Promise callbacks) are executed before macrotasks (e.g., `setTimeout` callbacks) in the event loop. Understanding this order of execution is crucial for handling async code effectively.",
					"code": ""
				},
				{
					"title": "How can you achieve parallel execution of Promises?",
					"description": "You can use `Promise.all()` to execute multiple Promises in parallel. Each Promise in the array runs concurrently, and you get the results in the same order as the Promises.",
					"code": "const promises = [promise1, promise2, promise3];\nPromise.all(promises).then((results) => {\n  // Handle results\n});"
				},
				{
					"title": "Explain what happens when a Promise is in a 'pending' state.",
					"description": "A Promise is 'pending' when it's neither resolved nor rejected. It stays in this state until one of these events occurs. The event loop continues executing other tasks until the Promise settles.",
					"code": ""
				},
				{
					"title": "How can you cancel a Promise or cleanup resources when it's no longer needed?",
					"description": "You can use an `AbortController` and the `abort` method to cancel a Promise or cleanup resources associated with it. The Promise can catch the `AbortError` and handle it gracefully.",
					"code": "const controller = new AbortController();\nconst signal = controller.signal;\n\nconst myPromise = new Promise((resolve, reject) => {\n  // Asynchronous operation\n  // Listen for abort signal\n  signal.addEventListener('abort', () => {\n    reject(new DOMException('Aborted', 'AbortError'));\n    // Cleanup resources\n  });\n});\n\n// To cancel the Promise\ncontroller.abort();"
				},
				{
					"title": "How can you implement retry logic using Promises?",
					"description": "You can implement retry logic by recursively calling a function that returns a Promise. In each iteration, you can retry or reject the Promise based on specific conditions.",
					"code": "function retryOperation(maxRetries) {\n  return someAsyncOperation()\n    .catch((error) => {\n      if (maxRetries > 0) {\n        console.log('Retrying...');\n        return retryOperation(maxRetries - 1);\n      }\n      throw error; // Max retries reached\n    });\n}"
				},
				{
					"title": "Explain the concept of 'Promise.race()' and provide a use case for it.",
					"description": "`Promise.race()` resolves or rejects as soon as any of the Promises in the array settles. It's useful for implementing timeout logic. For example, you can use it to set a maximum execution time for an asynchronous operation.",
					"code": "Promise.race([myPromise, timeoutPromise]).then((result) => {\n  // Handle result (myPromise resolved within timeout)\n}).catch((error) => {\n  // Handle error (myPromise took too long)\n});"
				}
			]
		},
		{
			"title": "Array Methods",
			"docs": [
				{
					"title": "push()",
					"description": "Adds one or more elements to the end of an array and returns the new length of the array. Useful for appending elements to an existing array.",
					"code": "const fruits = ['apple', 'banana'];\nfruits.push('cherry');\n// Result: fruits is now ['apple', 'banana', 'cherry']"
				},
				{
					"title": "pop()",
					"description": "Removes the last element from an array and returns that element. Helpful for extracting and using the last item in an array.",
					"code": "const fruits = ['apple', 'banana', 'cherry'];\nconst removedFruit = fruits.pop();\n// Result: removedFruit is 'cherry', fruits is now ['apple', 'banana']"
				},
				{
					"title": "shift()",
					"description": "Removes the first element from an array and returns that element. Ideal for dequeuing items from a queue-like data structure.",
					"code": "const fruits = ['apple', 'banana', 'cherry'];\nconst removedFruit = fruits.shift();\n// Result: removedFruit is 'apple', fruits is now ['banana', 'cherry']"
				},
				{
					"title": "unshift()",
					"description": "Adds one or more elements to the beginning of an array and returns the new length of the array. Good for prepending items to an array.",
					"code": "const fruits = ['banana', 'cherry'];\nfruits.unshift('apple');\n// Result: fruits is now ['apple', 'banana', 'cherry']"
				},
				{
					"title": "concat()",
					"description": "Combines two or more arrays and returns a new array without modifying the original arrays. Useful for creating a merged copy of arrays.",
					"code": "const fruits1 = ['apple', 'banana'];\nconst fruits2 = ['cherry', 'orange'];\nconst combinedFruits = fruits1.concat(fruits2);\n// Result: combinedFruits is ['apple', 'banana', 'cherry', 'orange']"
				},
				{
					"title": "slice()",
					"description": "Returns a shallow copy of a portion of an array into a new array. Great for extracting specific sections of an array without altering the original.",
					"code": "const fruits = ['apple', 'banana', 'cherry', 'orange'];\nconst slicedFruits = fruits.slice(1, 3);\n// Result: slicedFruits is ['banana', 'cherry']"
				},
				{
					"title": "splice()",
					"description": "Changes the contents of an array by removing, replacing, or adding elements. Useful for precise control over array modification.",
					"code": "const fruits = ['apple', 'banana', 'cherry'];\nfruits.splice(1, 1, 'orange');\n// Result: fruits is now ['apple', 'orange', 'cherry']"
				},
				{
					"title": "forEach()",
					"description": "Executes a provided function once for each array element. Perfect for iterating through arrays and performing actions on each item.",
					"code": "const numbers = [1, 2, 3];\nnumbers.forEach((number) => {\n  console.log(number * 2);\n});\n// Result: Prints 2, 4, 6"
				},
				{
					"title": "map()",
					"description": "Creates a new array by applying a function to each element of an existing array. Great for transforming one array into another.",
					"code": "const numbers = [1, 2, 3];\nconst doubledNumbers = numbers.map((number) => number * 2);\n// Result: doubledNumbers is [2, 4, 6]"
				},
				{
					"title": "filter()",
					"description": "Creates a new array with all elements that pass a provided test. Useful for selectively extracting elements based on a condition.",
					"code": "const numbers = [1, 2, 3, 4, 5];\nconst evenNumbers = numbers.filter((number) => number % 2 === 0);\n// Result: evenNumbers is [2, 4]"
				},
				{
					"title": "reduce()",
					"description": "Applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.",
					"code": "const array = [1, 2, 3, 4, 5];\n\nconst sum = array.reduce(function(accumulator, currentValue) {\n    return accumulator + currentValue;\n}, 0);\n\n// The 'sum' variable now contains the total sum of all elements in 'array'."
				},
				{
					"title": "some()",
					"description": "Checks if at least one element in the array satisfies a provided condition.",
					"code": "const array = [10, 20, 30, 40, 50];\n\nconst isGreaterThan25 = array.some(function(element) {\n    return element > 25;\n});\n\n// 'isGreaterThan25' is true because at least one element (30, 40, and 50) is greater than 25."
				},
				{
					"title": "every()",
					"description": "Checks if all elements in the array satisfy a provided condition.",
					"code": "const array = [5, 10, 15, 20, 25];\n\nconst isMultipleOf5 = array.every(function(element) {\n    return element % 5 === 0;\n});\n\n// 'isMultipleOf5' is true because all elements are multiples of 5."
				}
			]
		}
	]
}